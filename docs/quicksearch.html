<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"jsoncache.js.html":{"id":"jsoncache.js.html","title":"Source: jsoncache.js","body":" json-fetch-cache Classes JSONCache Source: jsoncache.js 'use strict'; const request = require('request-promise'); /** * Represents a JSON Cache */ class JSONCache { /** * Represents a JSONCache * @constructor * @param {string} url URL for the location of the remote json * @param {number} maximumCacheTime The maximum amount of time that the cache should be allowed to be stale */ constructor(url, maximumCacheTime) { /** * URL for the cache to fetch from * @type {string} * @private */ this._url = url; /** * Maximum amount of time to cache data * @type {number} * @private */ this._maximumCacheTime = maximumCacheTime || 3000; /** * The data cache, a JSON formatted object * @type {json} * @private */ this._cache = null; /** * Date corresponding to the last time the cache was refreshed * @type {Date} * @private */ this._lastRefresh = null; /** * Whether or not the cache is currently refreshing, * determines whether or not the cache will be returned or delayed until refreshed * @type {boolean} * @private */ this._refreshing = false; /** * An array of refresh functions to be performed * @type {Array&lt;function&gt;} * @private */ this._refreshQueue = []; } /** * Whether or not the data has expired past the maximumCacheTime * @readonly * @type {boolean} * @private */ get dataIsCurrent(){ return this._cache &amp;&amp; ((Date.now() - this._cache.creation) &lt; this._maximumCacheTime); } /** * Refresh the cached data * @param {function} Function to push onto the refresh queue if there is currently a refresh in progress * @returns {Promise&lt;string&gt;} describing the status * @private */ refresh(funct) { const self = this; return new Promise((resolve, reject) =&gt; { self._refreshQueue.push(funct); if (!self._refreshing) { self._refreshing = true; self.retrieve() .then((data) =&gt; { self._cache = data; self._lastRefresh = Date.now(); self._refreshing = false; self.processRefreshQueue(data); resolve(data); }) .catch(console.error); } }); } /** * Retrieve the most recent data from the specified url * @returns {Promise&lt;json&gt;} * @private */ retrieve() { return new Promise((resolve, reject) =&gt; { var self = this; request(self._url) .then(function (body) { var data; try { data = JSON.parse(body); } catch (e) { data = null; reject(e); } if (!data) { var error; error = new Error(`Invalid JSON from ${self._url}`); reject (error); } resolve(data); }) .catch((error) =&gt; { console.error(error); }); }); } /** * Process the next entry in the event queue * @returns {Promise&lt;json&gt;} * @private */ processRefreshQueue (data) { return new Promise((resolve, reject) =&gt; { while (this._refreshQueue.length) { this._refreshQueue.shift()() .then((data) =&gt; resolve(data)) .catch(console.error); } }); } /** * Get the cached data * @returns {Promise&lt;json&gt;} */ getData() { const self = this; return new Promise((resolve, reject) =&gt; { if (self.dataIsCurrent !== null &amp;&amp; self.dataIsCurrent) { resolve(self._cache); } else { self.refresh() .then((data) =&gt; { resolve(data); }) .catch(console.err); } }); } } module.exports = JSONCache; × Search results Close Documentation generated by JSDoc 3.4.2 on Wednesday, October 19th 2016, 17:45:32 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" json-fetch-cache Classes JSONCache Classes Classes JSONCache × Search results Close Documentation generated by JSDoc 3.4.2 on Wednesday, October 19th 2016, 17:45:37 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" json-fetch-cache Classes JSONCache json-fetch-cacheA simple package for fetching JSON from a URL and caching it for a decided amount of time. Installation$ npm i -S json-fetch-cacheUsagevar Cache = require(&quot;json-fetch-cache&quot;); const pcCache = new Cache('http://content.warframe.com/dynamic/worldState.php', 10000); pcCache.getData().then((data) =&gt; { console.log(data); process.exit(0); }) .catch((error)=&gt;{ console.error(error); }) × Search results Close Documentation generated by JSDoc 3.4.2 on Wednesday, October 19th 2016, 17:45:37 using the DocStrap template. "},"JSONCache.html":{"id":"JSONCache.html","title":"Class: JSONCache","body":" json-fetch-cache Classes JSONCache Class: JSONCache JSONCache Represents a JSON Cache new JSONCache(url, maximumCacheTime) Represents a JSONCache Parameters: Name Type Description url string URL for the location of the remote json maximumCacheTime number The maximum amount of time that the cache should be allowed to be stale Source: jsoncache.js, line 7 Methods getData() Get the cached data Source: jsoncache.js, line 146 Returns: Type Promise.&lt;json&gt; × Search results Close Documentation generated by JSDoc 3.4.2 on Wednesday, October 19th 2016, 17:45:37 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
